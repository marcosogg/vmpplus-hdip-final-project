---
description: 
globs: 
alwaysApply: true
---
---
description: 
globs: 
alwaysApply: true
---
# Backend Implementation Rules for VMP PLUS with Supabase

This document defines the exact implementation requirements for the Supabase backend of the VMP PLUS project. Following these rules will ensure a reliable, secure, and properly structured backend system.

## Database Structure and Schema

### 1. Table Structure and Relationships

**RULE:** Create the following tables with these exact structures:

#### Users Table (Managed by Supabase Auth)
Supabase automatically manages the `auth.users` table. Do not modify this table directly.

#### Profiles Table
```sql
CREATE TABLE profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  email TEXT NOT NULL,
  full_name TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Trigger for updated_at
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();

-- RLS Policies
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- Users can read their own profile
CREATE POLICY "Users can read own profile"
ON profiles FOR SELECT
USING (auth.uid() = id);

-- Users can update their own profile
CREATE POLICY "Users can update own profile"
ON profiles FOR UPDATE
USING (auth.uid() = id);
```

#### Vendors Table
```sql
CREATE TABLE vendors (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  email TEXT,
  phone TEXT,
  address TEXT,
  status TEXT CHECK (status IN ('active', 'inactive', 'pending')) DEFAULT 'pending',
  notes TEXT,
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Trigger for updated_at
CREATE TRIGGER update_vendors_updated_at
BEFORE UPDATE ON vendors
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();

-- RLS Policies
ALTER TABLE vendors ENABLE ROW LEVEL SECURITY;

-- Authenticated users can read all vendors
CREATE POLICY "Authenticated users can read all vendors"
ON vendors FOR SELECT
TO authenticated
USING (true);

-- Authenticated users can insert vendors
CREATE POLICY "Authenticated users can insert vendors"
ON vendors FOR INSERT
TO authenticated
WITH CHECK (true);

-- Authenticated users can update vendors
CREATE POLICY "Authenticated users can update vendors"
ON vendors FOR UPDATE
TO authenticated
USING (true);

-- Authenticated users can delete vendors
CREATE POLICY "Authenticated users can delete vendors"
ON vendors FOR DELETE
TO authenticated
USING (true);
```

#### Contracts Table
```sql
CREATE TABLE contracts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  vendor_id UUID REFERENCES vendors(id) ON DELETE CASCADE NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  start_date DATE NOT NULL,
  end_date DATE NOT NULL,
  value NUMERIC(15, 2) DEFAULT 0,
  status TEXT CHECK (status IN ('draft', 'active', 'completed', 'terminated')) DEFAULT 'draft',
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT date_check CHECK (end_date >= start_date)
);

-- Trigger for updated_at
CREATE TRIGGER update_contracts_updated_at
BEFORE UPDATE ON contracts
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();

-- RLS Policies
ALTER TABLE contracts ENABLE ROW LEVEL SECURITY;

-- Authenticated users can read all contracts
CREATE POLICY "Authenticated users can read all contracts"
ON contracts FOR SELECT
TO authenticated
USING (true);

-- Authenticated users can insert contracts
CREATE POLICY "Authenticated users can insert contracts"
ON contracts FOR INSERT
TO authenticated
WITH CHECK (true);

-- Authenticated users can update contracts
CREATE POLICY "Authenticated users can update contracts"
ON contracts FOR UPDATE
TO authenticated
USING (true);

-- Authenticated users can delete contracts
CREATE POLICY "Authenticated users can delete contracts"
ON contracts FOR DELETE
TO authenticated
USING (true);
```

#### Documents Table
```sql
CREATE TABLE documents (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  entity_type TEXT NOT NULL CHECK (entity_type IN ('vendor', 'contract')),
  entity_id UUID NOT NULL,
  file_path TEXT NOT NULL,
  file_type TEXT,
  file_size INTEGER,
  uploaded_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Authenticated users can read all documents
CREATE POLICY "Authenticated users can read all documents"
ON documents FOR SELECT
TO authenticated
USING (true);

-- Authenticated users can insert documents
CREATE POLICY "Authenticated users can insert documents"
ON documents FOR INSERT
TO authenticated
WITH CHECK (true);

-- Authenticated users can delete documents
CREATE POLICY "Authenticated users can delete documents"
ON documents FOR DELETE
TO authenticated
USING (true);
```

### 2. Storage Buckets Setup

**RULE:** Create a document storage bucket with these exact settings:

```sql
-- Create the storage bucket for documents
INSERT INTO storage.buckets (id, name, public) 
VALUES ('documents', 'documents', false);

-- Set up RLS policies for the documents bucket
CREATE POLICY "Authenticated users can read documents"
ON storage.objects FOR SELECT
TO authenticated
USING (bucket_id = 'documents');

CREATE POLICY "Authenticated users can upload documents"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (bucket_id = 'documents');

CREATE POLICY "Authenticated users can update documents"
ON storage.objects FOR UPDATE
TO authenticated
USING (bucket_id = 'documents' AND owner = auth.uid());

CREATE POLICY "Authenticated users can delete documents"
ON storage.objects FOR DELETE
TO authenticated
USING (bucket_id = 'documents' AND owner = auth.uid());
```

## Supabase Client Integration

### 3. Supabase Client Setup

**RULE:** Create the Supabase client module in `src/lib/supabase.ts` with this exact pattern:

```typescript
import { createClient } from '@supabase/supabase-js';
import { Database } from '@/types/supabase';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables');
}

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);
```

### 4. Database Types Generation

**RULE:** Generate TypeScript types for your Supabase database:

1. Install the Supabase CLI (in project directory):
```bash
npm install supabase --save-dev
```

2. Generate database types (after database setup):
```bash
npx supabase gen types typescript --project-id your-project-id > src/types/supabase.ts
```

3. If the above doesn't work, manually create a simpler version:

```typescript
// src/types/supabase.ts
export type Json = string | number | boolean | null | { [key: string]: Json | undefined } | Json[]

export interface Database {
  public: {
    Tables: {
      profiles: {
        Row: {
          id: string
          email: string
          full_name: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id: string
          email: string
          full_name?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          email?: string
          full_name?: string | null
          created_at?: string
          updated_at?: string
        }
      }
      vendors: {
        Row: {
          id: string
          name: string
          email: string | null
          phone: string | null
          address: string | null
          status: string
          notes: string | null
          created_by: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          name: string
          email?: string | null
          phone?: string | null
          address?: string | null
          status?: string
          notes?: string | null
          created_by?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          name?: string
          email?: string | null
          phone?: string | null
          address?: string | null
          status?: string
          notes?: string | null
          created_by?: string | null
          created_at?: string
          updated_at?: string
        }
      }
      contracts: {
        Row: {
          id: string
          vendor_id: string
          title: string
          description: string | null
          start_date: string
          end_date: string
          value: number
          status: string
          created_by: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          vendor_id: string
          title: string
          description?: string | null
          start_date: string
          end_date: string
          value?: number
          status?: string
          created_by?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          vendor_id?: string
          title?: string
          description?: string | null
          start_date?: string
          end_date?: string
          value?: number
          status?: string
          created_by?: string | null
          created_at?: string
          updated_at?: string
        }
      }
      documents: {
        Row: {
          id: string
          name: string
          description: string | null
          entity_type: string
          entity_id: string
          file_path: string
          file_type: string | null
          file_size: number | null
          uploaded_by: string | null
          created_at: string
        }
        Insert: {
          id?: string
          name: string
          description?: string | null
          entity_type: string
          entity_id: string
          file_path: string
          file_type?: string | null
          file_size?: number | null
          uploaded_by?: string | null
          created_at?: string
        }
        Update: {
          id?: string
          name?: string
          description?: string | null
          entity_type?: string
          entity_id?: string
          file_path?: string
          file_type?: string | null
          file_size?: number | null
          uploaded_by?: string | null
          created_at?: string
        }
      }
    }
  }
}
```

## API Implementation

### 5. API Service Structure

**RULE:** Create these API service files with the specified structure:

```
src/lib/api/
├── auth.ts            # Authentication operations
├── vendors.ts         # Vendor CRUD operations
├── contracts.ts       # Contract CRUD operations
├── documents.ts       # Document operations
└── profiles.ts        # User profile operations
```

### 6. Common API Response Type

**RULE:** Use this consistent API response pattern in `src/types/api.ts`:

```typescript
export type ApiError = {
  message: string;
  status?: number;
  details?: unknown;
};

export type ApiResponse<T> = {
  data: T | null;
  error: ApiError | null;
};
```

### 7. API Error Handling Utility

**RULE:** Create this utility function in `src/lib/api/api-utils.ts`:

```typescript
import { ApiResponse, ApiError } from '@/types/api';

export async function handleApiError<T>(
  promise: Promise<T>
): Promise<ApiResponse<T>> {
  try {
    const data = await promise;
    return { data, error: null };
  } catch (error) {
    console.error('API Error:', error);
    
    const apiError: ApiError = {
      message: error instanceof Error ? error.message : 'An unknown error occurred',
      details: error
    };
    
    return { data: null, error: apiError };
  }
}
```

### 8. Vendor API Implementation

**RULE:** Implement the vendors API in `src/lib/api/vendors.ts` with this exact pattern:

```typescript
import { supabase } from '@/lib/supabase';
import { handleApiError } from './api-utils';
import { ApiResponse } from '@/types/api';
import { Database } from '@/types/supabase';

export type Vendor = Database['public']['Tables']['vendors']['Row'];
export type VendorInsert = Database['public']['Tables']['vendors']['Insert'];
export type VendorUpdate = Database['public']['Tables']['vendors']['Update'];

// Get all vendors
export async function getVendors(): Promise<ApiResponse<Vendor[]>> {
  return handleApiError(
    supabase
      .from('vendors')
      .select('*')
      .order('created_at', { ascending: false })
      .then(({ data, error }) => {
        if (error) throw error;
        return data as Vendor[];
      })
  );
}

// Get a single vendor by ID
export async function getVendorById(id: string): Promise<ApiResponse<Vendor>> {
  return handleApiError(
    supabase
      .from('vendors')
      .select('*')
      .eq('id', id)
      .single()
      .then(({ data, error }) => {
        if (error) throw error;
        return data as Vendor;
      })
  );
}

// Create a new vendor
export async function createVendor(vendor: VendorInsert): Promise<ApiResponse<Vendor>> {
  return handleApiError(
    supabase
      .from('vendors')
      .insert({
        ...vendor,
        created_by: supabase.auth.getUser().then(({ data }) => data.user?.id)
      })
      .select()
      .single()
      .then(({ data, error }) => {
        if (error) throw error;
        return data as Vendor;
      })
  );
}

// Update an existing vendor
export async function updateVendor(
  id: string,
  updates: VendorUpdate
): Promise<ApiResponse<Vendor>> {
  return handleApiError(
    supabase
      .from('vendors')
      .update(updates)
      .eq('id', id)
      .select()
      .single()
      .then(({ data, error }) => {
        if (error) throw error;
        return data as Vendor;
      })
  );
}

// Delete a vendor
export async function deleteVendor(id: string): Promise<ApiResponse<null>> {
  return handleApiError(
    supabase
      .from('vendors')
      .delete()
      .eq('id', id)
      .then(({ error }) => {
        if (error) throw error;
        return null;
      })
  );
}
```

### 9. Contract API Implementation

**RULE:** Implement the contracts API in `src/lib/api/contracts.ts` with this exact pattern:

```typescript
import { supabase } from '@/lib/supabase';
import { handleApiError } from './api-utils';
import { ApiResponse } from '@/types/api';
import { Database } from '@/types/supabase';

export type Contract = Database['public']['Tables']['contracts']['Row'];
export type ContractInsert = Database['public']['Tables']['contracts']['Insert'];
export type ContractUpdate = Database['public']['Tables']['contracts']['Update'];

// Get all contracts
export async function getContracts(): Promise<ApiResponse<Contract[]>> {
  return handleApiError(
    supabase
      .from('contracts')
      .select('*, vendors(name)')
      .order('created_at', { ascending: false })
      .then(({ data, error }) => {
        if (error) throw error;
        return data as unknown as Contract[];
      })
  );
}

// Get contracts for a specific vendor
export async function getContractsByVendorId(vendorId: string): Promise<ApiResponse<Contract[]>> {
  return handleApiError(
    supabase
      .from('contracts')
      .select('*')
      .eq('vendor_id', vendorId)
      .order('created_at', { ascending: false })
      .then(({ data, error }) => {
        if (error) throw error;
        return data as Contract[];
      })
  );
}

// Get a single contract by ID
export async function getContractById(id: string): Promise<ApiResponse<Contract>> {
  return handleApiError(
    supabase
      .from('contracts')
      .select('*, vendors(name)')
      .eq('id', id)
      .single()
      .then(({ data, error }) => {
        if (error) throw error;
        return data as unknown as Contract;
      })
  );
}

// Create a new contract
export async function createContract(contract: ContractInsert): Promise<ApiResponse<Contract>> {
  return handleApiError(
    supabase
      .from('contracts')
      .insert({
        ...contract,
        created_by: supabase.auth.getUser().then(({ data }) => data.user?.id)
      })
      .select()
      .single()
      .then(({ data, error }) => {
        if (error) throw error;
        return data as Contract;
      })
  );
}

// Update an existing contract
export async function updateContract(
  id: string,
  updates: ContractUpdate
): Promise<ApiResponse<Contract>> {
  return handleApiError(
    supabase
      .from('contracts')
      .update(updates)
      .eq('id', id)
      .select()
      .single()
      .then(({ data, error }) => {
        if (error) throw error;
        return data as Contract;
      })
  );
}

// Delete a contract
export async function deleteContract(id: string): Promise<ApiResponse<null>> {
  return handleApiError(
    supabase
      .from('contracts')
      .delete()
      .eq('id', id)
      .then(({ error }) => {
        if (error) throw error;
        return null;
      })
  );
}
```

### 10. Document API Implementation

**RULE:** Implement the documents API in `src/lib/api/documents.ts` with this exact pattern:

```typescript
import { supabase } from '@/lib/supabase';
import { handleApiError } from './api-utils';
import { ApiResponse } from '@/types/api';
import { Database } from '@/types/supabase';

export type Document = Database['public']['Tables']['documents']['Row'];
export type DocumentInsert = Database['public']['Tables']['documents']['Insert'];

// Helper to generate a unique file path
const generateFilePath = (entityType: string, entityId: string, fileName: string): string => {
  const extension = fileName.split('.').pop();
  const timestamp = new Date().getTime();
  return `${entityType}/${entityId}/${timestamp}-${fileName}`;
};

// Upload a document
export async function uploadDocument(
  file: File,
  entityType: 'vendor' | 'contract',
  entityId: string,
  name?: string
): Promise<ApiResponse<Document>> {
  // 1. Upload the file to storage
  const filePath = generateFilePath(entityType, entityId, file.name);
  
  return handleApiError(async () => {
    // Upload to storage
    const { error: uploadError } = await supabase.storage
      .from('documents')
      .upload(filePath, file);
      
    if (uploadError) throw uploadError;
    
    // Get current user
    const { data: userData } = await supabase.auth.getUser();
    
    // 2. Insert record in documents table
    const { data, error } = await supabase
      .from('documents')
      .insert({
        name: name || file.name,
        entity_type: entityType,
        entity_id: entityId,
        file_path: filePath,
        file_type: file.type,
        file_size: file.size,
        uploaded_by: userData.user?.id
      })
      .select()
      .single();
      
    if (error) throw error;
    return data as Document;
  });
}

// Get documents for an entity
export async function getDocumentsByEntity(
  entityType: 'vendor' | 'contract',
  entityId: string
): Promise<ApiResponse<Document[]>> {
  return handleApiError(
    supabase
      .from('documents')
      .select('*')
      .eq('entity_type', entityType)
      .eq('entity_id', entityId)
      .order('created_at', { ascending: false })
      .then(({ data, error }) => {
        if (error) throw error;
        return data as Document[];
      })
  );
}

// Get document by ID
export async function getDocumentById(id: string): Promise<ApiResponse<Document>> {
  return handleApiError(
    supabase
      .from('documents')
      .select('*')
      .eq('id', id)
      .single()
      .then(({ data, error }) => {
        if (error) throw error;
        return data as Document;
      })
  );
}

// Get download URL for a document
export async function getDocumentUrl(filePath: string): Promise<ApiResponse<string>> {
  return handleApiError(async () => {
    const { data, error } = await supabase.storage
      .from('documents')
      .createSignedUrl(filePath, 60); // 60 seconds expiry
      
    if (error) throw error;
    return data.signedUrl;
  });
}

// Delete a document
export async function deleteDocument(id: string): Promise<ApiResponse<null>> {
  return handleApiError(async () => {
    // First get the document to know the file path
    const { data: document, error: fetchError } = await supabase
      .from('documents')
      .select('file_path')
      .eq('id', id)
      .single();
      
    if (fetchError) throw fetchError;
    
    // Delete the file from storage
    const { error: storageError } = await supabase.storage
      .from('documents')
      .remove([document.file_path]);
      
    if (storageError) throw storageError;
    
    // Delete the document record
    const { error } = await supabase
      .from('documents')
      .delete()
      .eq('id', id);
      
    if (error) throw error;
    return null;
  });
}
```

### 11. Profile API Implementation

**RULE:** Implement the profiles API in `src/lib/api/profiles.ts` with this exact pattern:

```typescript
import { supabase } from '@/lib/supabase';
import { handleApiError } from './api-utils';
import { ApiResponse } from '@/types/api';
import { Database } from '@/types/supabase';

export type Profile = Database['public']['Tables']['profiles']['Row'];
export type ProfileUpdate = Database['public']['Tables']['profiles']['Update'];

// Get current user's profile
export async function getCurrentProfile(): Promise<ApiResponse<Profile>> {
  return handleApiError(async () => {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) throw new Error('Not authenticated');
    
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', user.id)
      .single();
      
    if (error) throw error;
    return data as Profile;
  });
}

// Update current user's profile
export async function updateProfile(updates: ProfileUpdate): Promise<ApiResponse<Profile>> {
  return handleApiError(async () => {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) throw new Error('Not authenticated');
    
    const { data, error } = await supabase
      .from('profiles')
      .update(updates)
      .eq('id', user.id)
      .select()
      .single();
      
    if (error) throw error;
    return data as Profile;
  });
}

// Create profile for new user (called after signup)
export async function createProfile(userId: string, email: string): Promise<ApiResponse<Profile>> {
  return handleApiError(
    supabase
      .from('profiles')
      .insert({
        id: userId,
        email: email
      })
      .select()
      .single()
      .then(({ data, error }) => {
        if (error) throw error;
        return data as Profile;
      })
  );
}
```

## Authentication Implementation

### 12. Auth API Implementation

**RULE:** Implement authentication in `src/lib/api/auth.ts` with this exact pattern:

```typescript
import { supabase } from '@/lib/supabase';
import { handleApiError } from './api-utils';
import { ApiResponse } from '@/types/api';
import { createProfile } from './profiles';

// Sign up with email and password
export async function signUp(email: string, password: string): Promise<ApiResponse<null>> {
  return handleApiError(async () => {
    const { data, error } = await supabase.auth.signUp({
      email,
      password,
    });
    
    if (error) throw error;
    
    // If the user was created, create a profile
    if (data.user) {
      await createProfile(data.user.id, email);
    }
    
    return null;
  });
}

// Sign in with email and password
export async function signIn(email: string, password: string): Promise<ApiResponse<null>> {
  return handleApiError(async () => {
    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });
    
    if (error) throw error;
    return null;
  });
}

// Sign out
export async function signOut(): Promise<ApiResponse<null>> {
  return handleApiError(async () => {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
    return null;
  });
}

// Get the current session
export async function getSession(): Promise<ApiResponse<any>> {
  return handleApiError(async () => {
    const { data, error } = await supabase.auth.getSession();
    if (error) throw error;
    return data.session;
  });
}

// Get the current user
export async function getUser(): Promise<ApiResponse<any>> {
  return handleApiError(async () => {
    const { data, error } = await supabase.auth.getUser();
    if (error) throw error;
    return data.user;
  });
}
```

### 13. Auth Hook Implementation

**RULE:** Implement the authentication hook in `src/hooks/use-auth.ts` with this exact pattern:

```typescript
import { useContext, createContext, useState, useEffect, ReactNode } from 'react';
import { Session, User } from '@supabase/supabase-js';
import { supabase } from '@/lib/supabase';

// Define types
type AuthContextType = {
  session: Session | null;
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  signIn: (email: string, password: string) => Promise<{ error: string | null }>;
  signUp: (email: string, password: string) => Promise<{ error: string | null }>;
  signOut: () => Promise<void>;
};

// Create context
const AuthContext = createContext<AuthContextType | undefined>(undefined);

// Provider component
export function AuthProvider({ children }: { children: ReactNode }) {
  const [session, setSession] = useState<Session | null>(null);
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  
  useEffect(() => {
    // Get initial session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setUser(session?.user ?? null);
      setIsLoading(false);
    });
    
    // Set up listener for auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (_event, session) => {
        setSession(session);
        setUser(session?.user ?? null);
        setIsLoading(false);
      }
    );
    
    // Clean up subscription
    return () => {
      subscription.unsubscribe();
    };
  }, []);
  
  // Sign in function
  const signIn = async (email: string, password: string) => {
    try {
      const { error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });
      
      return { error: error ? error.message : null };
    } catch (error: any) {
      return { error: error.message || 'An unknown error occurred' };
    }
  };
  
  // Sign up function
  const signUp = async (email: string, password: string) => {
    try {
      const { error } = await supabase.auth.signUp({
        email,
        password,
      });
      
      return { error: error ? error.message : null };
    } catch (error: any) {
      return { error: error.message || 'An unknown error occurred' };
    }
  };
  
  // Sign out function
  const signOut = async () => {
    await supabase.auth.signOut();
  };
  
  const value = {
    session,
    user,
    isLoading,
    isAuthenticated: !!session,
    signIn,
    signUp,
    signOut,
  };
  
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

// Hook for using the auth context
export function useAuth() {
  const context = useContext(AuthContext);
  
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  
  return context;
}
```

## Security and Best Practices

### 14. Security Rules

**RULE:** Follow these security practices:

1. **Always use Row Level Security (RLS)**:
   - Every table must have RLS enabled
   - Define appropriate policies for each table
   - Test policies to ensure they work correctly

2. **Auth Security**:
   - Never store authentication tokens in localStorage
   - Use Supabase's built-in session management
   - Implement proper logout functionality

3. **Data Validation**:
   - Validate data on both client and server sides
   - Use database constraints for data integrity
   - Implement proper error handling for failed validations

4. **File Storage Security**:
   - Use signed URLs for file access
   - Set appropriate expirations for signed URLs
   - Validate file types and sizes before upload

### 15. Database Management (Continued)

**RULE:** Follow these database management practices:

1. **SQL Scripts**:
   - Store all SQL scripts in a `db/` directory
   - Comment scripts clearly
   - Include rollback commands for each script

2. **Database Initialization**:
   - Create a master initialization script that sets up the entire database
   - Test initialization script in a fresh environment
   - Include seed data for testing and development

3. **Schema Management**:
   - Keep schema changes versioned
   - Document all schema changes with date and purpose
   - Follow a consistent naming convention for all database objects

4. **Indexes and Performance**:
   - Create indexes for frequently queried columns
   - Add indexes for foreign keys
   - Consider adding indexes for columns used in WHERE clauses:
     ```sql
     -- Index for vendor lookups by status
     CREATE INDEX idx_vendors_status ON vendors(status);
     
     -- Index for contract date range searches
     CREATE INDEX idx_contracts_dates ON contracts(start_date, end_date);
     ```

5. **Data Migrations**:
   - Create migration scripts for any schema changes
   - Test migrations against production-like data
   - Include validation checks before and after migrations:
     ```sql
     -- Migration to add a new column
     DO $$
     BEGIN
       -- Check if column doesn't exist yet
       IF NOT EXISTS (
         SELECT FROM information_schema.columns 
         WHERE table_name = 'vendors' AND column_name = 'category'
       ) THEN
         -- Add the column
         ALTER TABLE vendors ADD COLUMN category TEXT;
       END IF;
     END $$;
     ```

6. **Constraints and Data Integrity**:
   - Use appropriate constraints (PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK)
   - Implement triggers for complex data validations
   - Use transactions for multi-step data operations:
     ```sql
     -- Example transaction
     BEGIN;
     
     -- Operations that need to happen together
     INSERT INTO vendors (name, email, status) VALUES ('New Vendor', 'contact@vendor.com', 'active');
     -- Get the vendor_id
     INSERT INTO contracts (vendor_id, title, start_date, end_date) 
     VALUES ((SELECT id FROM vendors WHERE email = 'contact@vendor.com'), 'Initial Contract', CURRENT_DATE, CURRENT_DATE + INTERVAL '1 year');
     
     COMMIT;
     ```

### 16. Real-time Subscriptions

**RULE:** Implement real-time data subscriptions where appropriate:

1. **Set Up Subscriptions**:
```typescript
// In a component that needs real-time updates
import { useEffect, useState } from 'react';
import { supabase } from '@/lib/supabase';
import { Vendor } from '@/types/supabase';

export function VendorListRealtime() {
  const [vendors, setVendors] = useState<Vendor[]>([]);
  
  useEffect(() => {
    // Initial fetch
    const fetchVendors = async () => {
      const { data } = await supabase
        .from('vendors')
        .select('*')
        .order('created_at', { ascending: false });
        
      if (data) {
        setVendors(data);
      }
    };
    
    fetchVendors();
    
    // Set up real-time subscription
    const subscription = supabase
      .channel('vendors-changes')
      .on('postgres_changes', 
        { event: '*', schema: 'public', table: 'vendors' }, 
        (payload) => {
          // Handle different change types
          if (payload.eventType === 'INSERT') {
            setVendors(prev => [payload.new as Vendor, ...prev]);
          } else if (payload.eventType === 'UPDATE') {
            setVendors(prev => 
              prev.map(vendor => 
                vendor.id === payload.new.id ? payload.new as Vendor : vendor
              )
            );
          } else if (payload.eventType === 'DELETE') {
            setVendors(prev => 
              prev.filter(vendor => vendor.id !== payload.old.id)
            );
          }
        }
      )
      .subscribe();
    
    // Clean up subscription
    return () => {
      supabase.removeChannel(subscription);
    };
  }, []);
  
  return (
    // Render vendors list
  );
}
```

2. **Performance Considerations**:
   - Use subscriptions only for frequently updated data
   - Filter subscriptions to relevant data
   - Handle reconnection logic

### 17. Advanced Queries and Data Operations

**RULE:** Implement efficient data operations:

1. **Pagination**:
```typescript
export async function getVendorsPaginated(
  page: number = 1,
  pageSize: number = 10
): Promise<ApiResponse<{ vendors: Vendor[], count: number }>> {
  return handleApiError(async () => {
    // Get total count
    const { count, error: countError } = await supabase
      .from('vendors')
      .select('*', { count: 'exact', head: true });
      
    if (countError) throw countError;
    
    // Get paginated data
    const from = (page - 1) * pageSize;
    const to = from + pageSize - 1;
    
    const { data, error } = await supabase
      .from('vendors')
      .select('*')
      .order('created_at', { ascending: false })
      .range(from, to);
      
    if (error) throw error;
    
    return {
      vendors: data as Vendor[],
      count: count || 0
    };
  });
}
```

2. **Filtering and Searching**:
```typescript
export async function searchVendors(
  query: string,
  status?: string
): Promise<ApiResponse<Vendor[]>> {
  return handleApiError(async () => {
    let queryBuilder = supabase
      .from('vendors')
      .select('*');
    
    // Apply search filter if provided
    if (query) {
      queryBuilder = queryBuilder.or(
        `name.ilike.%${query}%,email.ilike.%${query}%`
      );
    }
    
    // Apply status filter if provided
    if (status) {
      queryBuilder = queryBuilder.eq('status', status);
    }
    
    const { data, error } = await queryBuilder.order('created_at', { ascending: false });
    
    if (error) throw error;
    return data as Vendor[];
  });
}
```

3. **Joins and Related Data**:
```typescript
export async function getVendorWithContracts(
  vendorId: string
): Promise<ApiResponse<{ vendor: Vendor, contracts: Contract[] }>> {
  return handleApiError(async () => {
    // Get vendor
    const { data: vendor, error: vendorError } = await supabase
      .from('vendors')
      .select('*')
      .eq('id', vendorId)
      .single();
      
    if (vendorError) throw vendorError;
    
    // Get related contracts
    const { data: contracts, error: contractsError } = await supabase
      .from('contracts')
      .select('*')
      .eq('vendor_id', vendorId)
      .order('start_date', { ascending: false });
      
    if (contractsError) throw contractsError;
    
    return {
      vendor: vendor as Vendor,
      contracts: contracts as Contract[]
    };
  });
}
```

### 18. File Handling

**RULE:** Use these patterns for file operations:

1. **File Upload with Progress**:
```typescript
export async function uploadDocumentWithProgress(
  file: File,
  entityType: 'vendor' | 'contract',
  entityId: string,
  name: string,
  onProgress: (progress: number) => void
): Promise<ApiResponse<Document>> {
  const filePath = `${entityType}/${entityId}/${Date.now()}-${file.name}`;
  
  return handleApiError(async () => {
    // Upload with progress tracking
    const { error: uploadError } = await supabase.storage
      .from('documents')
      .upload(filePath, file, {
        onUploadProgress: (progress) => {
          const percentage = (progress.loaded / progress.total) * 100;
          onProgress(percentage);
        },
      });
      
    if (uploadError) throw uploadError;
    
    // Get current user
    const { data: userData } = await supabase.auth.getUser();
    
    // Create document record
    const { data, error } = await supabase
      .from('documents')
      .insert({
        name,
        entity_type: entityType,
        entity_id: entityId,
        file_path: filePath,
        file_type: file.type,
        file_size: file.size,
        uploaded_by: userData.user?.id
      })
      .select()
      .single();
      
    if (error) throw error;
    return data as Document;
  });
}
```

2. **Batch File Operations**:
```typescript
export async function deleteMultipleDocuments(
  documentIds: string[]
): Promise<ApiResponse<null>> {
  return handleApiError(async () => {
    // Get all file paths
    const { data: documents, error: fetchError } = await supabase
      .from('documents')
      .select('id, file_path')
      .in('id', documentIds);
      
    if (fetchError) throw fetchError;
    
    // Delete files from storage
    const filePaths = documents.map(doc => doc.file_path);
    
    const { error: storageError } = await supabase.storage
      .from('documents')
      .remove(filePaths);
      
    if (storageError) throw storageError;
    
    // Delete document records
    const { error } = await supabase
      .from('documents')
      .delete()
      .in('id', documentIds);
      
    if (error) throw error;
    return null;
  });
}
```

### 19. Error Handling and Logging

**RULE:** Implement comprehensive error handling:

1. **Error Categorization**:
```typescript
// In src/types/api.ts
export enum ErrorCode {
  AUTHENTICATION = 'auth_error',
  PERMISSION = 'permission_error',
  NOT_FOUND = 'not_found',
  VALIDATION = 'validation_error',
  SERVER = 'server_error',
  UNKNOWN = 'unknown_error'
}

export type ApiError = {
  message: string;
  code: ErrorCode;
  details?: unknown;
};

// Usage in API functions
function categorizeError(error: any): ApiError {
  if (error.code === 'PGRST301') {
    return {
      message: 'Resource not found',
      code: ErrorCode.NOT_FOUND,
      details: error
    };
  }
  
  if (error.code === '42501') {
    return {
      message: 'You don\'t have permission to perform this action',
      code: ErrorCode.PERMISSION,
      details: error
    };
  }
  
  // Add more error categories
  
  return {
    message: error.message || 'An unknown error occurred',
    code: ErrorCode.UNKNOWN,
    details: error
  };
}
```

2. **Centralized Error Logging**:
```typescript
// In src/lib/api/api-utils.ts
export function logError(error: any, context?: string) {
  const errorContext = context ? `[${context}] ` : '';
  console.error(`${errorContext}Error:`, error);
  
  // In a real app, you might want to log to a service like Sentry
  // if (typeof window !== 'undefined' && window.Sentry) {
  //   window.Sentry.captureException(error, {
  //     tags: { context }
  //   });
  // }
}

export async function handleApiError<T>(
  promise: Promise<T>,
  context?: string
): Promise<ApiResponse<T>> {
  try {
    const data = await promise;
    return { data, error: null };
  } catch (error) {
    logError(error, context);
    
    const apiError = categorizeError(error);
    return { data: null, error: apiError };
  }
}
```









