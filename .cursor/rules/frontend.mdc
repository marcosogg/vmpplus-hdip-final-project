---
description: 
globs: 
alwaysApply: true
---
# Frontend Implementation Rules for VMP PLUS

This document outlines the strict requirements for the frontend implementation of the VMP PLUS project. Follow these rules precisely to ensure a consistent, functional, and maintainable user interface.

## Component Architecture

### 1. Component Organization

**RULE:** Structure components according to this hierarchy and naming:

```
src/components/
├── ui/                     # Generic UI components (from shadcn/ui)
├── layout/                 # Layout structure components
├── vendor/                 # Vendor-specific components
├── contract/               # Contract-specific components
├── document/               # Document-specific components
├── auth/                   # Authentication components
└── common/                 # Shared utility components
```

**RULE:** Component files must:
- Use kebab-case for filenames (e.g., `vendor-card.tsx`)
- Use PascalCase for component names (e.g., `VendorCard`)
- Export components as named exports, not default exports

### 2. Page Structure

**RULE:** Organize page components in a dedicated directory:

```
src/pages/
├── auth/                  # Auth-related pages
├── dashboard/             # Dashboard pages
├── vendor/                # Vendor management pages
├── contract/              # Contract management pages
└── document/              # Document-specific pages
```

**RULE:** Page components must:
- Handle their own data fetching with loading/error states
- Follow a consistent layout pattern
- Be wrapped with appropriate layout components

### 3. Component Composition

**RULE:** Follow these component composition patterns:

1. **Page Components**: Handle data fetching and overall layout
2. **Feature Components**: Implement specific features (e.g., `VendorForm`)
3. **UI Components**: Provide reusable UI elements (e.g., `Button`, `Card`)

**RULE:** Components must not:
- Mix UI rendering with complex business logic
- Directly use Supabase client outside of API functions
- Exceed 300 lines of code (split if necessary)

## UI Implementation with shadcn/ui

### 4. shadcn/ui Component Usage

**RULE:** Use shadcn/ui components for all basic UI elements:

- `Button` for all buttons
- `Input`, `Select`, etc. for form controls
- `Card` for content containers
- `Table` for data display
- `Dialog` for modals
- `Dropdown` for menu interfaces

**RULE:** Install shadcn/ui components using the CLI:
```bash
npx shadcn-ui add button
npx shadcn-ui add card
# etc.
```

**RULE:** Do not modify the core shadcn/ui components in the `ui/` directory.

### 5. Styling Guidelines

**RULE:** Use Tailwind CSS classes for styling with these principles:

- Use shadcn/ui components as the foundation
- Apply Tailwind classes directly to elements
- Use consistent spacing: `p-4`, `gap-2`, etc.
- Follow these color selections:
  - Primary: Blue (`blue-600`)
  - Secondary: Slate (`slate-600`)
  - Success: Green (`green-600`)
  - Warning: Amber (`amber-500`)
  - Error: Red (`red-600`)
  - Background: White or very light gray (`gray-50`)

**RULE:** Do not:
- Use inline styles (`style={{}}`)
- Create separate CSS files (except for global styles)
- Override shadcn/ui default styling unnecessarily

## Data Handling & Forms

### 6. Data Fetching Pattern

**RULE:** Follow this exact pattern for data fetching in components:

```tsx
import { useState, useEffect } from 'react';
import { getVendors } from '@/lib/api/vendors';
import { Vendor } from '@/types/vendor';

export function VendorList() {
  const [vendors, setVendors] = useState<Vendor[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function loadVendors() {
      setIsLoading(true);
      setError(null);
      
      try {
        const { data, error } = await getVendors();
        
        if (error) {
          setError(error.message);
          return;
        }
        
        setVendors(data || []);
      } catch (err) {
        setError('An unexpected error occurred');
        console.error(err);
      } finally {
        setIsLoading(false);
      }
    }
    
    loadVendors();
  }, []);

  // Loading state
  if (isLoading) {
    return <div className="p-4 text-center">Loading vendors...</div>;
  }
  
  // Error state
  if (error) {
    return <div className="p-4 text-red-500">Error: {error}</div>;
  }
  
  // Empty state
  if (vendors.length === 0) {
    return <div className="p-4 text-center">No vendors found.</div>;
  }
  
  // Data display
  return (
    <div>
      {/* Render vendors */}
    </div>
  );
}
```

**RULE:** Always include these states:
- Loading state
- Error state
- Empty data state
- Normal data display

### 7. Form Implementation

**RULE:** Implement forms using this exact pattern:

```tsx
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { createVendor } from '@/lib/api/vendors';
import { VendorFormValues } from '@/types/vendor';

interface VendorFormProps {
  onSuccess?: () => void;
}

export function VendorForm({ onSuccess }: VendorFormProps) {
  const [formData, setFormData] = useState<VendorFormValues>({
    name: '',
    email: '',
    phone: '',
    status: 'pending'
  });
  
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError(null);
    
    try {
      const { data, error } = await createVendor(formData);
      
      if (error) {
        setError(error.message);
        return;
      }
      
      // Reset form or handle success
      setFormData({
        name: '',
        email: '',
        phone: '',
        status: 'pending'
      });
      
      // Call success callback if provided
      if (onSuccess) {
        onSuccess();
      }
    } catch (err) {
      setError('An unexpected error occurred');
      console.error(err);
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {error && (
        <div className="p-3 text-sm text-red-500 bg-red-50 border border-red-200 rounded">
          {error}
        </div>
      )}
      
      <div className="space-y-2">
        <Label htmlFor="name">Name</Label>
        <Input
          id="name"
          name="name"
          value={formData.name}
          onChange={handleChange}
          required
        />
      </div>
      
      {/* Other form fields */}
      
      <Button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Saving...' : 'Save Vendor'}
      </Button>
    </form>
  );
}
```

**RULE:** Form implementation must include:
- Proper state management for form data
- Loading/submitting state
- Error handling and display
- Form validation (either controlled or with HTML5 validation)
- Disabled state during submission
- Success handling

### 8. Form Validation with Zod

**RULE:** For complex forms, use Zod validation with react-hook-form:

```tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';

// Define schema
const vendorSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Please enter a valid email address'),
  phone: z.string().optional(),
  status: z.enum(['active', 'inactive', 'pending'])
});

type VendorFormData = z.infer<typeof vendorSchema>;

export function VendorFormWithValidation() {
  const form = useForm<VendorFormData>({
    resolver: zodResolver(vendorSchema),
    defaultValues: {
      name: '',
      email: '',
      phone: '',
      status: 'pending'
    }
  });
  
  const onSubmit = async (data: VendorFormData) => {
    // Submit data
    console.log(data);
  };
  
  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Name</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        {/* Other form fields */}
        
        <Button type="submit" disabled={form.formState.isSubmitting}>
          {form.formState.isSubmitting ? 'Saving...' : 'Save Vendor'}
        </Button>
      </form>
    </Form>
  );
}
```

## Layout and Responsive Design

### 9. Layout Components

**RULE:** Create these essential layout components:

1. **MainLayout** - The base layout with header, sidebar and content area:

```tsx
import { ReactNode } from 'react';
import { Header } from './header';
import { Sidebar } from './sidebar';

interface MainLayoutProps {
  children: ReactNode;
}

export function MainLayout({ children }: MainLayoutProps) {
  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <div className="flex flex-1">
        <Sidebar />
        <main className="flex-1 p-6 overflow-auto">
          {children}
        </main>
      </div>
    </div>
  );
}
```

2. **PageHeader** - Consistent page header with title and actions:

```tsx
import { ReactNode } from 'react';

interface PageHeaderProps {
  title: string;
  description?: string;
  actions?: ReactNode;
}

export function PageHeader({ title, description, actions }: PageHeaderProps) {
  return (
    <div className="flex justify-between items-start mb-6 pb-4 border-b">
      <div>
        <h1 className="text-2xl font-bold">{title}</h1>
        {description && <p className="text-gray-500 mt-1">{description}</p>}
      </div>
      {actions && <div>{actions}</div>}
    </div>
  );
}
```

**RULE:** Every page component must:
- Be wrapped with the appropriate layout component
- Include a PageHeader component
- Handle its own responsive behavior

### 10. Responsive Design

**RULE:** Follow these responsive design patterns:

1. **Mobile-First Approach**:
   - Start with mobile layout
   - Use Tailwind breakpoints for larger screens: `sm:`, `md:`, `lg:`

2. **Responsive Patterns**:
   - Mobile: Single column layout
   - Tablet: Two-column where appropriate
   - Desktop: Multi-column as needed

3. **Tables and Lists**:
   - Use responsive tables that scroll horizontally on mobile
   - Consider switching to card view on very small screens

**RULE:** Required responsive breakpoints:
- Mobile: Default (< 640px)
- Tablet: `sm:` (≥ 640px)
- Desktop: `md:` (≥ 768px)
- Large Desktop: `lg:` (≥ 1024px)

## Navigation and State Management

### 11. Routing and Navigation

**RULE:** Implement routing using `react-router-dom` with these patterns:

1. **Router Configuration** in `src/router.tsx`:
```tsx
import { Routes, Route, Navigate } from 'react-router-dom';
import { ProtectedRoute } from '@/components/auth/protected-route';
import { MainLayout } from '@/components/layout/main-layout';
import { LoginPage } from '@/pages/auth/login-page';
import { DashboardPage } from '@/pages/dashboard/dashboard-page';
// Other imports

export function AppRouter() {
  return (
    <Routes>
      {/* Public routes */}
      <Route path="/login" element={<LoginPage />} />
      <Route path="/signup" element={<SignupPage />} />
      
      {/* Protected routes with MainLayout */}
      <Route path="/" element={<ProtectedRoute><MainLayout /></ProtectedRoute>}>
        <Route index element={<Navigate to="/dashboard" replace />} />
        <Route path="dashboard" element={<DashboardPage />} />
        <Route path="vendors" element={<VendorListPage />} />
        <Route path="vendors/:id" element={<VendorDetailPage />} />
        <Route path="contracts" element={<ContractListPage />} />
        <Route path="contracts/:id" element={<ContractDetailPage />} />
        {/* Other routes */}
      </Route>
      
      {/* 404 route */}
      <Route path="*" element={<NotFoundPage />} />
    </Routes>
  );
}
```

2. **Navigation Components** must use `Link` or `NavLink`:
```tsx
import { NavLink } from 'react-router-dom';

export function Sidebar() {
  return (
    <nav className="w-64 bg-gray-100 p-4">
      <ul className="space-y-2">
        <li>
          <NavLink 
            to="/dashboard" 
            className={({ isActive }) => 
              `block p-2 rounded ${isActive ? 'bg-blue-100 text-blue-800' : 'text-gray-600 hover:bg-gray-200'}`
            }
          >
            Dashboard
          </NavLink>
        </li>
        {/* Other navigation items */}
      </ul>
    </nav>
  );
}
```

### 12. Local State Management

**RULE:** Manage state according to these principles:

1. **Component State**:
   - Use `useState` for component-specific state
   - Use `useReducer` for complex state logic

2. **Form State**:
   - Use `useState` for simple forms
   - Use `react-hook-form` for complex forms

3. **Application State**:
   - Use React Context for shared state (auth, theme, etc.)
   - No complex state management libraries (Redux, Zustand, etc.) needed

**RULE:** Context creation pattern:
```tsx
import { createContext, useContext, useState, ReactNode } from 'react';

// Define context type
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

// Create context with default values
const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// Provider component
export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// Custom hook for using this context
export function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
}
```

## Error Handling and Loading States

### 13. Error Handling

**RULE:** Implement these error handling patterns:

1. **API Request Errors**:
```tsx
try {
  const { data, error } = await apiFunction();
  
  if (error) {
    // Handle error from API
    setError(error.message);
    return;
  }
  
  // Process data
} catch (err) {
  // Handle unexpected errors
  console.error('Unexpected error:', err);
  setError('An unexpected error occurred');
}
```

2. **User-Facing Error Messages**:
```tsx
{error && (
  <div className="p-3 my-3 text-sm text-red-500 bg-red-50 border border-red-200 rounded">
    {error}
  </div>
)}
```

3. **Form Validation Errors**:
   - Display inline with form fields
   - Provide clear actionable messages
   - Use red text and/or borders

### 14. Loading States

**RULE:** Implement these loading state patterns:

1. **Page Loading**:
```tsx
if (isLoading) {
  return (
    <div className="flex justify-center items-center h-48">
      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
    </div>
  );
}
```

2. **Button Loading**:
```tsx
<Button disabled={isSubmitting}>
  {isSubmitting ? (
    <>
      <span className="mr-2 animate-spin">⟳</span>
      Saving...
    </>
  ) : 'Save'}
</Button>
```

3. **Inline Loading**:
```tsx
<div className="flex items-center space-x-2">
  <div className="animate-pulse h-4 w-24 bg-gray-200 rounded"></div>
  <div className="animate-pulse h-4 w-16 bg-gray-200 rounded"></div>
</div>
```

## Quality Requirements

### 15. Accessibility

**RULE:** Follow these accessibility requirements:

1. **Semantic HTML**:
   - Use appropriate elements (`button`, `a`, `nav`, etc.)
   - Use heading hierarchy (`h1`, `h2`, etc.) correctly

2. **ARIA attributes** when necessary:
```tsx
<button
  aria-label="Close dialog"
  aria-expanded={isOpen}
  onClick={closeDialog}
>
  &times;
</button>
```

3. **Keyboard navigation**:
   - All interactive elements must be focusable
   - Tab order should be logical
   - Support keyboard actions (Enter for buttons, etc.)

4. **Color contrast**:
   - Use sufficient contrast ratios (4.5:1 minimum)
   - Don't rely on color alone to convey information

### 16. Code Quality

**RULE:** Maintain these code quality standards:

1. **TypeScript Type Safety**:
   - Use explicit types for all props, state, and function parameters
   - Avoid `any` and `unknown` types
   - Use proper type narrowing with conditionals

2. **Component Props**:
```tsx
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'outline';
  size?: 'sm' | 'md' | 'lg';
  isLoading?: boolean;
  disabled?: boolean;
  onClick?: () => void;
  children: React.ReactNode;
}

export function Button({
  variant = 'primary',
  size = 'md',
  isLoading = false,
  disabled = false,
  onClick,
  children
}: ButtonProps) {
  // Component implementation
}
```

3. **Consistent Code Style**:
   - Use arrow functions for component definitions
   - Use destructuring for props and state
   - Maintain consistent spacing and indentation

4. **Clean Code**:
   - Extract repeated logic into utility functions
   - Extract repeated UI patterns into components
   - Use meaningful variable and function names

## Implementation Process

### 17. Component Development Workflow

**RULE:** Follow this workflow when building components:

1. **Define Props Interface** first
2. **Create Component Structure** with basic HTML/JSX
3. **Add Styling** with Tailwind classes
4. **Implement Component Logic** (state, effects, handlers)
5. **Add Loading and Error States**
6. **Test Different Scenarios** (empty state, loaded state, error state)

### 18. Testing Components

**RULE:** Verify components using these checks:

1. **Visual Rendering**:
   - Component renders correctly in all states
   - Responsive behavior works as expected
   - Styling matches design guidelines

2. **Functional Testing**:
   - User interactions work (clicks, inputs, etc.)
   - Data fetching and submission work
   - Error handling works as expected

3. **Edge Cases**:
   - Empty state handling
   - Error state handling
   - Loading state display
   - Very long or unexpected data values

## Final Rules

**RULE:** The frontend implementation MUST:
1. Use shadcn/ui components as the foundation
2. Follow consistent naming and structure patterns
3. Handle loading, error, and empty states properly
4. Be responsive across device sizes
5. Maintain TypeScript type safety
6. Follow accessibility best practices

**RULE:** The frontend implementation MUST NOT:
1. Mix business logic with UI rendering
2. Use inline styles instead of Tailwind classes
3. Create deeply nested component hierarchies
4. Leave console.log statements in production code
5. Implement features without proper error handling
6. Use any when specific types should be used

By following these rules precisely, you will create a consistent, maintainable, and robust frontend implementation for the VMP PLUS project.